<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PVD Experiment Designer - Documentation</title>
    <!-- Script for rendering LaTeX math formulas -->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        /* Basic styling for readability */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.7;
            margin: 0;
            background-color: #f6f8fa;
        }
        .container {
            max-width: 800px;
            margin: 20px auto;
            padding: 40px;
            background-color: #fff;
            border: 1px solid #d1d5da;
            border-radius: 8px;
        }
        .header {
            border-bottom: 2px solid #e1e4e8;
            padding-bottom: 20px;
            margin-bottom: 30px;
        }
        h1, h2, h3 {
            color: #24292e;
        }
        h1 {
            font-size: 2.5em;
            margin-bottom: 0.2em;
        }
        h2 {
            font-size: 1.8em;
            border-bottom: 1px solid #e1e4e8;
            padding-bottom: 10px;
            margin-top: 40px;
        }
        h3 {
            font-size: 1.4em;
            margin-top: 30px;
        }
        .launch-button {
            display: inline-block;
            padding: 12px 24px;
            background-color: #2ea44f; /* Green button for launching */
            color: white;
            text-decoration: none;
            font-size: 1.2em;
            font-weight: 600;
            border-radius: 6px;
            transition: background-color 0.2s;
            margin-top: 10px;
        }
        .launch-button:hover {
            background-color: #2c974b;
        }
        p, li {
            font-size: 1.1em;
            color: #333;
        }
        code {
            background-color: #f0f0f0;
            padding: 0.2em 0.4em;
            margin: 0;
            font-size: 85%;
            border-radius: 3px;
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;
        }
        pre {
            background-color: #f6f8fa;
            padding: 16px;
            overflow: auto;
            border-radius: 6px;
        }
        .meta-info {
            font-style: italic;
            color: #586069;
        }
    </style>
</head>
<body>
    <div class="container">
        
        <div class="header">
            <h1>PVD Experiment Designer & Analyzer</h1>
            <p class="meta-info">This document provides an overview of the PVD web-based tool, designed to assist researchers in designing, analyzing, and optimizing experiments based on Response Surface Methodology (RSM).</p>
            <!-- This link points directly to your program file -->
            <a href="./pvd.htm" class="launch-button" target="_blank" rel="noopener noreferrer">Launch PVD Control Program</a>
        </div>

        <article>
            <h2>1. Overview &amp; Workflow</h2>
            <p>
                The application guides the user through a structured workflow for performing a Design of Experiments (DoE) analysis for a PVD process. The primary goal is to find the optimal set of process parameters (factors) to maximize one or more desired outcomes (responses), such as film thickness, purity, and conductivity.
            </p>
            <p>The user workflow is as follows:</p>
            <ol>
                <li><strong>Design Experiment</strong>: The user defines the process factors (e.g., Temperature, Pressure), their minimum and maximum operating values, and selects a DoE method. The tool provides default factors for Pressure, Substrate Temp, O2/Ar Ratio, Power, Source Distance, and Deposition Time.</li>
                <li><strong>Generate Plan</strong>: The tool generates a detailed experimental plan, listing the specific combination of factor settings for each run.</li>
                <li><strong>Enter Data</strong>: The user performs the experiments and enters the measured responses (Thickness, Purity, and Conductivity) into the data table. A feature to fill the table with simulated data based on a pre-defined mathematical model is also available for validation and demonstration purposes.</li>
                <li><strong>Analyze & Optimize</strong>: The tool automatically performs a regression analysis to create a mathematical model linking the factors to the responses. It calculates key statistical metrics, predicts optimal conditions, and visualizes the relationships using contour plots.</li>
                <li><strong>Export</strong>: A summary report of the data, models, and predicted optima can be exported as a PDF document.</li>
            </ol>

            <h2>2. Design of Experiments (DoE) Methods</h2>
            <p>The tool implements three standard Response Surface Methodology (RSM) designs. RSM is a collection of statistical and mathematical techniques useful for developing, improving, and optimizing processes.</p>
            
            <h3>2.1. Full Factorial Design</h3>
            <p>A full factorial experiment measures the response at all possible combinations of the factor levels. For <em>k</em> factors, each at 2 levels (min and max), this design consists of $2^k$ runs.</p>
            <ul>
                <li><strong>Purpose</strong>: Excellent for identifying the main effects of factors and their interactions.</li>
                <li><strong>Implementation</strong>: The <code>generateFactorial</code> function creates this plan. It is primarily suited for fitting first-order models with interaction terms and serves as the foundation for the Central Composite Design.</li>
            </ul>

            <h3>2.2. Box-Behnken Design (BBD)</h3>
            <p>A Box-Behnken design is an efficient, three-level design used for fitting second-order (quadratic) models. It does not contain runs at the extreme vertices of the experimental space, which can be advantageous when these points represent expensive or unsafe operating conditions.</p>
            <ul>
                <li><strong>Purpose</strong>: To fit a quadratic model and find optima without needing to test extreme factor combinations.</li>
                <li><strong>Structure</strong>: The design is constructed by combining two-level factorial designs with incomplete block designs. The <code>generateBoxBehnken</code> function implements this by creating runs where factors are at their center points while pairs of other factors are at their min/max levels.</li>
                <li><strong>Requirement</strong>: Requires at least 3 varying factors.</li>
            </ul>
            
            <h3>2.3. Central Composite Design (CCD)</h3>
            <p>A CCD is the most common design used for building second-order models. It is highly efficient and flexible.</p>
            <ul>
                <li><strong>Purpose</strong>: To efficiently estimate a second-order model, allowing for the detection of curvature in the response surface and the location of optimal process settings.</li>
                <li><strong>Structure</strong>: The <code>generateCentralComposite</code> function builds the design from three types of points:
                    <ol>
                        <li><strong>Factorial Points</strong>: The corners of the experimental space (coded as -1 and +1).</li>
                        <li><strong>Center Points</strong>: Replicate runs at the center of the domain (coded as 0).</li>
                        <li><strong>Axial (or Star) Points</strong>: Points along the axes of the factors, set at a distance 'α' from the center, which enable the estimation of quadratic terms.</li>
                    </ol>
                </li>
                <li><strong>CCD Type (α value)</strong>:
                    <ul>
                        <li><strong>Face-Centered (α=1.0)</strong>: The axial points are located on the "faces" of the factorial cube, confining all runs within the specified min/max range.</li>
                        <li><strong>Rotatable (α = k¹/⁴)</strong>: Here, α is calculated from the number of factors (k) to ensure the prediction variance is constant at points equidistant from the center. This can result in axial points outside the min/max range.</li>
                    </ul>
                </li>
            </ul>

            <h2>3. Mathematical Foundation</h2>
            
            <h3>3.1. Coding of Variables</h3>
            <p>To simplify calculations, real-world factor values (e.g., 400°C to 800°C) are "coded" into a dimensionless range from -1 to +1.</p>
            $$ \text{Coded Value} = \frac{2 \times (\text{Real Value} - \text{Min Value})}{(\text{Max Value} - \text{Min Value})} - 1 $$
            <p>The <code>uncodeValue</code> function reverses this process.</p>

            <h3>3.2. The Model</h3>
            <p>The application uses a second-order polynomial model. For two factors, $X_1$ and $X_2$, the model is:</p>
            $$ y = \beta_0 + \beta_1X_1 + \beta_2X_2 + \beta_{12}X_1X_2 + \beta_{11}X_1^2 + \beta_{22}X_2^2 + \epsilon $$
            <p>Where $y$ is the predicted response (e.g., Thickness), $\beta_0$ is the intercept, $\beta_i$ are linear coefficients, $\beta_{ij}$ are interaction coefficients, $\beta_{ii}$ are quadratic coefficients, and $\epsilon$ is the error.</p>

            <h3>3.3. Model Fitting: Method of Least Squares</h3>
            <p>The coefficients ($\beta$) are determined using the method of least squares, solved via the matrix equation:</p>
            $$ b = (X^T X)^{-1} X^T y $$
            <p>Where <strong>b</strong> is the vector of coefficients, <strong>X</strong> is the design matrix, and <strong>y</strong> is the vector of observed responses.</p>
            
            <h2>4. Analysis of Statistical Parameters</h2>
            <p>The <code>buildModel</code> function calculates several key statistics to evaluate the quality, significance, and predictive capability of the fitted second-order polynomial model.</p>
            
            <h3>4.1. R-Squared ($R^2$)</h3>
            <p>Also known as the coefficient of determination, R-Squared measures the proportion of the total variation in the observed response variable that is explained by the model. A higher $R^2$ is generally better.</p>

            <h3>4.2. Adjusted R-Squared (Adj $R^2$)</h3>
            <p>A modified version of R-Squared that is adjusted for the number of predictors in the model. It is more suitable for comparing models with different numbers of terms and helps prevent "overfitting".</p>

            <h3>4.3. Predicted R-Squared (Pred $R^2$)</h3>
            <p>This statistic measures how well the model is expected to predict responses for new observations. A large difference between Adj $R^2$ and Pred $R^2$ suggests the model may be overfit.</p>

            <h3>4.4. PRESS (Predicted Residual Sum of Squares)</h3>
            <p>A form of cross-validation used to calculate Predicted $R^2$. It is calculated by systematically removing each data point, fitting the model, and summing the squares of the prediction errors. A lower PRESS value is better.</p>

            <h3>4.5. Adequate Precision (Adeq. Precision)</h3>
            <p>This measures the signal-to-noise ratio. A ratio greater than 4 is generally desirable and indicates the model provides sufficient signal to be used for navigating the design space.</p>
            
            <h3>4.6. Standard Deviation (Std. Dev.)</h3>
            <p>The standard deviation of the residuals, representing the typical distance that the observed values fall from the fitted regression line. This value is in the same units as the response variable.</p>

            <h3>4.7. Coefficient of Variation (C.V. %)</h3>
            <p>The standard deviation expressed as a percentage of the mean of the observed responses. It provides a standardized, relative measure of model error, independent of the response units.</p>

            <h3>4.8. Coefficient Statistics (Std. Error & 95% CI)</h3>
            <p>These statistics assess the significance of each individual term in the model. If the 95% Confidence Interval (CI) range for a term contains zero, the term is generally not statistically significant and its effect cannot be distinguished from random noise.</p>


            <h2>5. Optimization</h2>
            
            <h3>5.1. Single-Response Optimization</h3>
            <p>The <code>findGlobalOptimum</code> function seeks the combination of factor settings that maximizes a single response (Thickness, Purity, or Conductivity) using a random walk numerical optimization algorithm.</p>
            
            <h3>5.2. Multi-Response Optimization (Weighted Score)</h3>
            <p>The tool optimizes multiple responses using a weighted sum approach. The user assigns an importance weight to each of the three responses using sliders. The <code>findCombinedOptimum</code> function then maximizes a combined score to find a "compromise" setting that provides the best overall outcome.</p>
            $$ \text{Score} = (W_{thickness} \cdot N_{thickness}) + (W_{purity} \cdot N_{purity}) + (W_{conductivity} \cdot N_{conductivity}) $$
            <p>Where $W$ is the weight for each response and $N$ is the normalized predicted value for that response.</p>

            <h2>6. Visualization</h2>
            <p>The tool generates 2D contour plots to help visualize the response surface. A star symbol (★) on the plot marks the location of the predicted mathematical optimum for that response. When creating a 2D plot for a design with more than two factors, the other factors are held constant at their center point (average) value.</p>
            
            <h2>7. About the File</h2>
            <ul>
                <li><strong>Author</strong>: NitaD, Univ Paris-Saclay</li>
                <li><strong>Version</strong>: 1.0 (June 2025)</li>
            </ul>
        
        </article>

    </div>
</body>
</html>
